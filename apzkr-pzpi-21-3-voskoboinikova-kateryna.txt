Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система дистанційного моніторингу стану здоров’я пацієнтів

Студентка гр. ПЗПІ-21-3 	__________________ Воскобойнікова К. С.
                               (підпис)

Керівник роботи 		__________________ доц. Лещинська І.О.
                         (підпис)
                           Роботу захищено «__»_________2024 р.
                           з оцінкою _________________________

Комісія: 				__________________ доц. Лещинська І.О.
    (підпис)
    __________________ доц. Лещинський В.О.
    (підпис)
    __________________ ст.викл. Сокорчук І.П.
    (підпис)
    
Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук                 Кафедра програмної інженерії           
Спеціальність 121 – Інженерія програмного забезпечення                                 
Курс                3                Семестр                                      6                                   
Навчальна дисципліна Архітектура програмного забезпечення                        

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                    Воскобойнікової Катерині Сергіївні                                     
1. Тема роботи: «Програмна система дистанційного моніторингу стану здоров'я пацієнтів»                                                                            
2. Термін узгодження завдання з лабораторних робіт « 10 »   березня   2024 р.
3. Термін здачі студентом закінченої роботи « 8 »   червня   2024 р.
4. Вихідні дані до проекту (роботи): В програмній системі передбачити: додавання нового пацієнта, редагування медичної картки, внесення даних до медичної картки, відстеження стану здоров’я пацієнта. Використовувати ОС Windows 10, СУБД Microsoft SQL Server 2019, середовище розробки Microsoft Visual Studio 2019
5. Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз та концептуальне моделювання предметної області, постановка задачі, архітектура програмної системи, опис частин програмного коду, висновки, перелік посилань, додатки                                                                 
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень): 
діаграма прецедентів, діаграма розгортання, діаграма компонентів, ER-діаграма, інтерфейс застосунку                                                               


КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання етапів	Примітка
1	Функціональна специфікація програмного проекту	31.03.2024	виконано
2	Проектування програмного проекту	10.04.2024	виконано
3	Кодування програмного проекту	25.05.2024	виконано
4	Оформлення пояснювальної записки	08.06.2024	виконано
5	Захист курсової роботи	12.06.2024	виконано

Дата видачі завдання «    10    »      березня      2024 р.

Керівник                                                      __________________ доц. Лещинська І.О.
                                                                   (підпис)

Завдання прийняла до виконання   
ст. гр. ПЗПІ-21-3                                    __________________ Воскобойнікова К.С..                           
                                                          (підпис)


РЕФЕРАТ


Пояснювальна записка до курсової роботи: 77 с., 14 рис., 8 табл., 9 додатків, 5 джерел.
ДИСТАНЦІЙНИЙ МОНІТОРИНГ, СТАН ЗДОРОВ'Я, ПАЦІЄНТ, ЛІКАР, ЗБІР ДАНИХ, МЕДИЧНА КАРТА, ТЕМПЕРАТУРА, ПУЛЬС.

Об’єктом дослідження даної роботи є галузь охорони здоров’я. Дана робота спрямована на вирішення актуального на поточний час питання про покращення дистанційної взаємодії між пацієнтом та лікарем.
Метою курсової роботи є розробка інноваційного програмного продукту, який дозволить пацієнтам та лікарям використовувати ефективні інструменти для дистанційного моніторингу стану здоров'я за допомогою збору даних про температуру, пульс та інших параметрів через спеціальний розумний годинник, який зчитує поточні дані пацієнта, аналізує та відправляє до основної системи, також розробляємий продукт має  полегшити доступ до медичних даних та підвищити якість діагностики та лікування.
Методи розробки базуються на використанні мови програмування С# на платформі .NET 8.0 та з використанням технології ASP.NET Core 8.0 для серверної частини, для бази  даних використано MS SQL Server 2019, веб-додаток базується на технології Angular 17, мобільний додаток – на технології Kotlin, для розробки програмного забезпечення для IoT пристрою було обрано технологію ASP.NET Core 8.0, у якості пристрою обрано Raspberry Pi. 
Результатом виконання роботи є програмна реалізація системи дистанційного моніторингу стану здоров’я пацієнтів, перегляд зібраних медичних даних, внесення даних про стан здоров’я за допомогою прототипу смарт-годинників. Програмна система складається з сервера, веб-додатку, мобільного додатку  та смарт-годинника.


ЗМІСТ
	

ВСТУП	7
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1 Аналіз предметної області	8
1.2 Аналіз існуючих аналогів	8
1.3 Концептуальне моделювання предметної області	10
2 ПОСТАНОВКА ЗАДАЧІ	11
2.1 Потреби цільової аудиторії системи та ринку	11
2.2 Головні функції системи	11
2.3 Припущення та залежності	12
2.4 Ризики програмної системи	12
2.5 Вимоги до компонентів системи та технологій розробки	13
3 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	16
3.1 Серверна частина	16
3.1.1 Проектування серверної частини	16
3.1.2 Архітектура серверної частини	17
3.1.3 Опис частин програмного коду серверної частини	17
3.1.3.1 REST API	17
3.1.3.2 Аутентифікація	18
3.1.3.3 Локалізація	18
3.1.3.4 Безпека даних	19
3.1.3.5 Моделі даних, інтерфейси, сервіси	19
3.2 Клієнтська частина	21
3.2.1 Проектування клієнтської частини	21
3.2.2 Архітектура клієнтської частини	21
3.2.3 Опис частин програмного коду клієнтської частини	22
3.2.3.1 Локалізація	22
3.2.3.2 Валідація	23
3.2.4 Інтерфейс користувача	24
3.2 IoT пристрій	28
3.2.1 Проектування програмного забезпечення для IoT пристрою	28
3.2.2 Архітектура програмного забезпечення для IoT пристрою	28
3.2.3 Опис частин коду програмного забезпечення для IoT пристрою	29
3.2.3.1 Моделі даних та сервіси	29
3.2.3.2 Локалізація	30
3.2.3.3 Статистика	32
Висновки	33
Перелік посилань	34
Додаток А Схеми та діаграми	35
Додаток Б Специфікація REST	39
Додаток В NotificationRepository.cs	45
Додаток Г app.module.ts	48
Додаток Д app-routing.module.ts	59
Додаток Е Program.cs	68
Додаток Ж MeasurementsController.cs	74
Додаток И Результат перевірки на плагіат	77

 
ВСТУП


У сучасному світі люди все більше приділяють увагу турботі про своє здоров’я. Однак, існують деякі значущі проблеми, пов'язані з доступністю та наданням медичної допомоги. Результати даної курсової роботи направлені на застосування у сфері охорони здоров’я. Розроблений проект можна використовувати в лікарнях, поліклініках, медичних центрах, він також буде корисним для приватних лікарів, медичних працівників, що працюють на дому, та пацієнтів, які потребують постійного спостереження.
Актуальність роботи полягає в необхідності зменшити навантаження на лікарні та лікарів, покращити взаємодію з пацієнтами. Дистанційний моніторинг стану здоров’я дозволить швидко  виявляти проблеми зі здоров'ям пацієнтів, забезпечить постійний контроль за їх станом і зменшить кількість непотрібних відвідувань медичних установ, що оптимізує навантаження на лікарні.
Метою завдання курсової роботи є розробка програмної системи за принципами «чистого коду» [2], яка вирішить існуючі обмеження та незручності, дозволивши пацієнтам відстежувати свій стан здоров'я в будь-який час та в будь-якому місці, легко отримати доступ до своїх медичних даних. Система надасть зручну реєстрацію та авторизацію користувачів, інструменти для збору даних про стан здоров'я та доступ до медичних даних. 
Для успішного досягнення поставленої мети були вивченні різні типи архітектури ПЗ, патерни проектування [1] та реальні приклади їх застосування.  


1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Аналіз предметної області


У поточних умовах, пацієнтам стало важко здійснити особистий візит до лікаря, що може призвести до затримок у виявленні медичних проблем на ранніх стадіях та у доступі до ефективного лікування. Пацієнти можуть зіткнутися з довгими чергами, важкістю запису на прийом або віддаленими місцями проживання. 
Предметною областю даного проекту є галузь охорони здоров’я. Ця робота дозволить покращити якість медичного обслуговування та зменшити навантаження на систему охорони здоров'я. Проект «StayHealth» розробляється з метою надання можливості відстежувати стан здоров'я пацієнтів в будь-який час та в будь-якому місці. Також проект вирішить наявні обмеження та незручності, шляхом створення системи, яка дозволить пацієнтам дистанційно надсилати показники свого здоров’я, слідкувати за ними з боку лікарень, отримувати консультації від лікарів дистанційно та зберігати свої медичні дані в єдиному електронному реєстрі.


1.2 Аналіз існуючих аналогів


На ринку існують деякі аналоги системи, призначені для дистанційного відстежування стану здоров’я. Однією з таких систем є «Apple Health» – це інтегрована медична платформа, розроблена компанією Apple для моніторингу та управління станом здоров'я користувачів їхніх пристроїв. «Apple Health» надає користувачам можливість відстежувати різні параметри стану здоров'я, такі як активність, серцевий ритм, сон, харчування та інші, але система не має інтеграції з медичними установами. «Apple Health» доступний тільки для користувачів пристроїв Apple, програма інтегрована безпосередньо в операційну систему IOS. «Apple Health» є безкоштовним сервісом, Apple заробляє на продажі апаратних пристроїв і послуг, пов'язаних із здоров'ям, таких як Apple Watch.
Серед переваг системи «StayHealth» в порівнянні з «Apple Health» можна виділити:
–	«StayHealth» буде доступним не лише для користувачів пристроїв Apple, але і для користувачів різних платформ, включаючи Android.
–	«StayHealth» буде мати доступну ціну для широкого кола пацієнтів.
Ці переваги роблять проект «StayHealth» перспективним для розвитку на ринку дистанційного моніторингу стану здоров'я.
Модель монетизації проекту базується на декількох джерелах доходу:
–	Користувачі будуть платити щомісячну або щорічну плату за доступ до системи.
–	Система «StayHealth» буде використовувати рекламу для отримання додаткових доходів.
Модель монетизації проекту «StayHealth» має потенціал для отримання доходів. Пряма оплата від користувачів є основним джерелом доходу, система буде доступна за доступною ціною для широкого кола пацієнтів. Платні підписки від медичних закладів також є потенційним джерелом доходу, оскільки система є цінним та зручним інструментом для медичних закладів. Реклама може бути додатковим джерелом доходу, але її роль менша, ніж у інших двох джерел.


1.3 Концептуальне моделювання предметної області


Програмний продукт «StayHealth» забезпечить пацієнтів та лікарів зручними інструментами для дистанційного моніторингу стану здоров'я та надання медичної допомоги.
Основною ідеєю «StayHealth» є створення доступної системи, яка надасть пацієнтам та лікарям зручний та зрозумілий доступ до медичних даних, що допоможе з діагностикою та виявленням проблем зі здоров'я. Лікарі отримають можливість надсилати повідомлення пацієнтам та робити медичні записи, не використовуючи паперові медичні картки для цього.  Концепція «StayHealth» передбачає систему, що поєднує технології збору медичних даних, їх аналізу та зберігання медичних записів.

 
2 ПОСТАНОВКА ЗАДАЧІ
2.1 Потреби цільової аудиторії системи та ринку


«StayHealth» задовольнить: пацієнтів(звичайних людей), які піклуються про своє здоров’я, але мають  певні проблеми з регулярними відвідуваннями лікарів, хочуть більш корисно проводити свій час, не витрачаючи його на черги; лікарні та лікарів, які хочуть оптимізувати свій робочий час, зменшити або повністю позбутися паперової роботи та звітності.
Основні потреби клієнтів:
–	можливість віддалено відслідковувати свій стан здоров'я;
–	отримувати консультації від лікарів на відстані;
–	єдиний електронний реєстр для зберігання своїх медичних даних;
–	автоматичний збір даних про стан здоров'я.
До основних потреб ринку відноситься:
–	зручна система, яка дозволяють віддалено стежити за здоров'ям пацієнтів та надасть зручні інструменти для цього;
–	усунення необхідності самостійно зберігати дані пацієнтів;
–	зменшення навантаження шляхом проведення дистанційних консультацій.


2.2 Головні функції системи


Серед основних функцій системи можна зазначити наступні:
–	реєстрація та авторизація для користувачів(ролі – пацієнт, лікар, адміністратор);
–	збір інформації про стан здоров’я пацієнтів;
–	перегляд медичних записів пацієнтів;
–	отримання дистанційної консультації від лікарів;
–	перегляд інформації про лікарів;
–	отримання пацієнтами повідомлень від своїх лікарів;
–	отримання статистики по зібраним показникам(температура, пульс, вага) пацієнтів;
–	можливість обрати інтерфейс українською або англійською мовою;
–	забезпечення високого рівню захисту персональних даних користувачів, включаючи конфіденційні медичні дані.


2.3 Припущення та залежності


Можемо визначити наступні припущення та залежності: 
–	користувач має базові навички користування браузером та мобільними застосунками, вміє встановлювати їх;
–	користувач має підключення до Інтернету;
–	лікар має комп’ютер або ноутбук на робочому місці;
–	на робочому комп’ютері лікаря встановлено браузер.


2.4 Ризики програмної системи


Головним ризиком для успішності програмної системи можна назвати появу конкурентів з подібною системою. Для запобігання цьому треба буде постійно отримувати зворотній зв’язок від користувачів та покращувати систему в залежності від них, відслідковувати тенденції ринку, при появі подібної нової системи проводити аналіз її функціоналу, за актуальності додавати цей функціонал до своєї системи, проводячи таким чином заняття вільних ніш. 
Також серед можливих ризиків технічні проблеми, які включають  проблеми з серверами та їх відключення, що призведе до переривання роботи системи. Для зменшення вірогідності виникнення цього ризику треба постійно проводити технічні обслуговування, мати резервні сервера, розробити план швидкого відновлення системи.
Є ризик витоку конфіденційних особистих даних користувачів, які підпадають в категорію чутливих(медичні дані). Для запобігання цього слід посилити заходи безпеки даних, використовувати шифрування та регулярно проводити аудит безпеки.
Система може бути не сприйнята користувачами, для зниження вірогідності виникнення цієї ситуації слід розгорнути велику рекламну кампанію в соцмережах, відвідувати з виступом презентації та конференції, які мають тематику та цільову аудиторію системи. 


2.5 Вимоги до компонентів системи та технологій розробки


При створенні програмної системи буде задіяно ряд технологій та фреймворків для забезпечення реалізації всіх основних функцій, зазначених  вище. 
У загальному представлені компоненти системи повинні задовольнити наступні вимоги:
а) Серверна частина буде включати наступні задачі:
1)	Система реєстрації для створення нових облікових записів для користувачів. 
2)	Система авторизації за допомогою даних, отриманих при реєстрації (електрона пошта та пароль).
3)	Засоби для управління всіма користувачами та даними системи. 
4)	Збір показників здоров’я пацієнтів за допомогою розумних пристроїв, обробка та збереження цих даних у базі даних, передача до веб-клієнту.
5)	Виведення статистики щодо отриманих показників здоров’я, передача статистика до веб-клієнту.
6)	Захист даних користувачів, які застосовуються для авторизації, шляхом хешування паролів в базі даних.
б) Клієнтська частина відповідатиме за надання зручного та адаптивного інтерфейсу для користування функціями серверної частини. Клієнтська частина надаватиме:
1)	Зручний інтерфейс для використання системи реєстрації та авторизації.
2)	Лікарю: можливість надсилати, редагувати й видаляти повідомлення та медичні записи, переглядати медичні карти пацієнтів, отримані зі смарт-девайсів вимірювання, статистику.
3)	Адміністратору: панель адміністрування для налаштування системи, управління користувачами та даними.
4)	Пацієнту: можливість переглядати та видаляти повідомлення від лікарів, переглядати свої медичні записи, переглядати профілі лікарів, свої вимірювання, отримані зі смарт-девайсів, статистику.
5)	Можливість обрати українську або англійську мову інтерфейсу для комфортного використання системи.
в) Мобільний програмний застосунок буде надавати пацієнтам доступ до системи через мобільний пристрій і включати такі функції:
1)	Зручний інтерфейс для реєстрації та авторизації.
2)	Можливість внесення власних показників здоров’я.
3)	Можливість перегляду стану здоров’я.
4)	Швидкий доступ до медичних даних.
5)	Можливість обрати українську або англійську мову інтерфейсу для комфортного використання системи.
г) Пристрій IoT буде виконувати наступні функції:
1)	Збір показників стану здоров’я користувачів (температура, пульс тощо).
2)	Обробка та передача зібраних даних до серверної частини.
3)	Виведення статистики для аналізу фізичного стану пацієнтів та виявлення відхилень від норми.
Серверна частина програмної системи буде розроблятися з використанням мови програмування C# на платформі .NET 8 та з використанням ASP.NET Core 8.0. У якості бази даних буде задіяно MS SQL Server 2019. Для зв’язку API із базою даних використовуватиметься Entity Framework Core 8.0. Автентифікація та авторизація буде здійснюватися за допомогою JSON Web Token для контролю надання доступу тільки для користувачів певних ролей. Клієнтська частина буде створена за допомогою фреймворку Angular 17, з використанням мови програмування TypeScript, також буде застосовано Bootstrap для забезпечення адаптивності веб-клієнта. За основу ІоТ пристрою буде взято Raspberry Pi, з застосуванням API, розробленого за допомогою ASP.NET Core 8.0. 

 
3 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
3.1 Серверна частина
3.1.1 Проектування серверної частини


Для кращого представлення функціональності серверної частини було створено діаграму прецедентів (див. Додаток А, рис. А.1).  На діаграмі є 4 види акторів: пацієнт, лікар, неавторизований користувач, адміністратор. В залежності від ролі кожен з них має різну функціональність (див. Додаток А, рис. А.1). Користувачі всіх ролей можуть переглядати загальну інформацію та авторизуватися. Неавторизований користувач може здійснити реєстрацію та авторизацію. Адміністратор може  переглядати всіх користувачів та їх дані, здійснювати операції управління, взаємодіяти з базою даних. Лікар може переглядати, редагувати та видаляти повідомлення та медичні записи пацієнтів, переглядати та редагувати свій профіль, переглядати профілі своїх пацієнтів, їх статистику та аналіз даних, отриманих зі смарт-девайсу. Пацієнт може переглядати свої повідомлення та медичні записи, переглядати та редагувати свій профіль, дивитись статистику та аналіз своїх даних, отриманих зі смарт-девайсу, переглядати профілі своїх лікарів.
Після побудови діаграми прецедентів та аналізу необхідного функціоналу, були визначені основні об’єкти системи, які треба винести у якості окремих сутностей: пацієнт, його вимірювання, медичні пристрої, типи медичних пристроїв(так як наявне отримання неспівпадаючих типів даних), типи крові(для заповнення профілю), медичні записи, повідомлення, лікар. Після цього була побудована ER-діаграма, для зручності та спрощення процесу побудови бази даних. Отримана ER-діаграма містить 9 основних сутностей зі зв’язками один-до-багатьох (див. Додаток А, рис. А.2). 


3.1.2 Архітектура серверної частини


Серверна частина розбита на контролери, сервіси та репозиторії. Основним відповідальним класом для маршрутизації запитів є Program.cs, де налаштовуються шляхи та інші конфігурації додатку.
Контролери, такі як UserAccountController, MedicalRecordController, PatientController та MedicalDeviceController, відповідають за обробку HTTP-запитів, розділення їх на відповідні сервіси та повернення відповідей на ці запити клієнту. Контролери містять методи, що відповідають на різні HTTP-запити, такі як GET, POST, PUT та DELETE.
Сервіси відповідають за бізнес-логіку додатку та виконання операцій над даними.
Репозиторії взаємодіють з базою даних та виконують операції збереження, оновлення, видалення та отримання даних.
Також використовується JSON Web Token (JWT) для забезпечення безпеки та автентифікації користувачів. JWT використовується для створення токенів, які підтверджують ідентичність користувачів і дозволяють їм отримувати доступ до ресурсів на сервері. Після успішної аутентифікації користувача, сервер генерує JWT, який містить інформацію про користувача та його ролі. Цей токен надсилається клієнту, який потім використовує його для авторизації при кожному запиті до сервера.


3.1.3 Опис частин програмного коду серверної частини
3.1.3.1 REST API


Для обміну даними використовується REST API. Кожен HTTP-запит відповідає певній операції, у даній системі за допомогою методу GET здійснюється отримання даних, через метод POST додаються нові дані в базу даних, DELETE їх видаляє, а PUT оновлює. Специфікація REST API наведена у додатку Б. У таблиці наведено посилання, використаний метод та призначення цього методу.


3.1.3.2 Аутентифікація


Для аутентифікації у додатку застосовано JSON Web Token. Для входу у систему користувач надсилає адресу електронної пошти та пароль. Після цього вони валідуються на сервері із використанням методів та формується JWT-токен. Параметри для генерації токенів у appsettings.json:
1 "jwt": {
2   "Issuer": "https://localhost:7049",
3   "Audience": "https://localhost:7049",
4   "Key": "LXqkbDzvSTbHXNYb0k7HhS7D3ICyKQlY"
5 }


3.1.3.3 Локалізація


Дані зберігаються в форматі UTC, щоб уникнути проблем з часовими зонами. Температурні дані зберігаються в базі даних у градусах Цельсія.


3.1.3.4 Безпека даних


Для уникнення витоку даних користувачів у системі наявне хешування паролів, збереження цих даних в базі даних у зашифрованому вигляді. 
Також додано аутентифікацію і авторизацію користувачів з використанням JSON Web Token. Завдяки використанню токенів, доступ до певної інформації надається тільки для тих користувачів, роль яких дозволяє це.      


3.1.3.5 Моделі даних, інтерфейси, сервіси


Першим кроком після створення та налаштування проекту було створення моделей, на основі розробленої ER-діаграми. Приклад створення однієї з моделей: 
01 namespace stayhealth.Models
02 {
03     public class Notification
04     {
05         public int NotificationId { get; set; }
06         public string Title { get; set; }
07         public string Content { get; set; }
08         public int PatientId { get; set; }
09         public DateTime Date { get; set; } = DateTime.UtcNow;
10         public int SenderId { get; set; } = 0;
11         public Patient Patient { get; set; }
12     }
13 }
Хочу звернути увагу на поля (рядки 8, 11), в яких реалізується зв’язок з іншою моделлю за допомогою Entity Framework Core. 
Наступним кроком було створення інтерфейсу та сервісу для кожної попередньо описаної моделі. Приклад частини коду інтерфейсу (INotificationRepository), який містить методи, необхідні для взаємодії з базою даних:
1 public interface INotificationRepository
2     {
3         Notification GetNotification(int notifId);
4         bool CreateNotification(Notification notification);
5         bool UpdateNotification(Notification notification);
6         bool DeleteNotification(Notification notification);
Реалізація методів, описаних у інтерфейсі INotificationRepository, міститься у сервісі NotificationRepository (див. Додаток В). Наприклад, отримання всіх повідомлень пацієнта за його ідентифікатором:
1         public ICollection<Notification> GetNotificationsByPatient(int patientId)
2         {
3             return _context.Notifications.Where(e => e.PatientId == patientId).ToList();
4         }
Всі інші моделі, їх інтерфейс та сервіс були створені таким же чином.  


3.2 Клієнтська частина
3.2.1 Проектування клієнтської частини


Для кращого представлення функцій веб-клієнту було створено діаграму прецедентів (див. Додаток А, рис. А.3).  На діаграмі є 3 види акторів: пацієнт, лікар, адміністратор. В залежності від ролі кожен з них має різну функціональність (див. Додаток А, рис. А.3). Усі користувачі кожної ролі можуть переглядати загальну інформацію про систему (головна сторінка) та авторизуватися. Адміністратор може контролювати всіх користувачів і їхні дані. Лікар може переглядати, редагувати та видаляти повідомлення та медичні записи пацієнтів, переглядати профілі пацієнтів, переглядати та статистику пацієнтів і аналізу даних, отриманих зі смарт-пристрою. Пацієнти можуть переглядати свої медичні записи та повідомлення, переглядати статистику та аналіз своїх даних зі смарт-пристроїв, а також переглядати профілі своїх лікарів.


3.2.2 Архітектура клієнтської частини


Проекти Angular складаються  з компонентів, а кожен компонент реалізує окрему частину інтерфейсу: головну сторінку, авторизацію, реєстрацію, додавання нового користувача тощо. Також у фреймворк вбудовані функції Two-Way Data Binding, що дозволяє автоматично оновлювати дані в інтерфейсі одразу при їх зміні.
Файл main.ts – є точкою входу у програму:
1 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
2 import { AppModule } from './app/app.module';
3 
4 platformBrowserDynamic().bootstrapModule(AppModule)
5   .catch(err => console.error(err));
Після завершення його роботи виконується перехід до компоненту app.module.ts, в якому підключені всі інші компоненти, з яких складається застосунок, та бібліотеки, які необхідні для його роботи (див. додаток Г). 
Кожен компонент, в свою чергу, складається з файлу розмітки HTML, файлу стилів CSS та файлу TypeScript, де реалізовані функції та логіка компоненту. 
Для управління шляхами використовується файл app-routing.module.ts (див. додаток Д).
За допомогою файлу app.component.html виконується автоматична підставка компонентів, які викликаються при взаємодії користувача з веб-клієнтом:
1 <div class="container">
2   <router-outlet></router-outlet>
3 </div>
Спілкування з серверною частиною веб-клієнт здійснює за використанням запитів.


3.2.3 Опис частин програмного коду клієнтської частини
3.2.3.1 Локалізація


Веб-додаток підтримує дві локалі: українську та англійську. Для їх реалізації було використано бібліотеки @ngx-translate/core та @ngx-translate/http-loader. У якості стандартної мови визначено українську, також є функція збереження вибору мови у локальному сховищі та зчитування при ініціалізації:
01   constructor(public authService: AuthService, private translate: TranslateService) {
02     const savedLanguage = localStorage.getItem('language') || 'ua';
03     this.translate.setDefaultLang(savedLanguage);
04     this.translate.use(savedLanguage);
05   }
06 
07   switchLanguage(language: string) {
08     this.translate.use(language);
09     localStorage.setItem('language', language);
10   }
Модуль перекладу налаштовано у app.module.ts (див. Додаток Г). Переклади рядків двома мовами містяться у файлах ua.json та en.json. Також з сервера отримуються дата та час у форматі UTC та за допомогою date pipe перекладаються у формат відповідної локалі. 


3.2.3.2 Валідація


Для забезпечення валідації відбувається перевірка введених даних за допомогою вбудованих засобів: перевірка з використанням атрибутів форм required, maxlength та minlength. У випадку заповнення поля неправильними даними, користувач отримає повідомлення про помилку та рекомендацію по її виправленню. Також за допомогою ngModel відбувається перевірка чи збігається початковий пароль та пароль, який був запитаний для підтвердження:
01 <div class="form-group mb-4">
02     <label for="passwordInput">{{ 'FORM.PASSWORD' | translate }}</label>
03     <input #password="ngModel"
04            name="password"
05            [(ngModel)]="registrationData.password"
06            type="password"
07            id="passwordInput"
08            class="form-control"
09            required
10            minlength="8" />
11     <div *ngIf="password.invalid && password.touched" class="text-danger">{{ 'FORM.PASSWORD_MIN_LENGTH' | translate }}</div>
12   </div>


3.2.4 Інтерфейс користувача


При запуску веб-клієнту першим чином користувач бачить головну сторінку, яка містить загальну інформацію, кнопки для здійснення авторизація або реєстрації, кнопки вибору мови інтерфейсу (рис. 3.2.1).

 
Рисунок 3.2.1 – Головна сторінка веб-застосунку програмної системи «StayHealth»

З головної сторінки неавторизований користувач зможе перейти на сторінку авторизації (рис. 3.2.2) або сторінку реєстрації (рис. 3.2.3).
 
Рисунок 3.2.2 – Сторінка авторизації у веб-застосунку програмної системи «StayHealth»

 
Рисунок 3.2.3 – Сторінка реєстрації у веб-застосунку програмної системи «StayHealth»

Далі користувач попадає на сторінку профілю. Вигляд профілю залежить від ролі користувача (рис. 3.2.4, рис. 3.2.5).
 
Рисунок 3.2.4 – Сторінка профілю та інтерфейс для пацієнта

 
Рисунок 3.2.5 – Сторінка профілю та інтерфейс для лікаря

Користувач, який авторизувався у ролі адміністратора, отримає доступ до панелі адміністрування (рис. 3.2.6).
 
Рисунок 3.2.6 – Панель адміністрування у веб-застосунку програмної системи «StayHealth»

Авторизація у ролі адміністратора та доступ до панелі адміністрування надає можливості для повного управління системою.


3.2 IoT пристрій
3.2.1 Проектування програмного забезпечення для IoT пристрою


Для кращого представлення функцій програмного забезпечення для IoT пристрою було створено діаграму прецедентів (див. Додаток А, рис. А.4).  На діаграмі є 2 види акторів: пацієнт та розумний пристрій. В залежності від ролі кожен з них має різну функціональність (див. Додаток А, рис. А.4). Пацієнт може переглядати показники свого здоров’я, отримані через пристрій, переглядати статистику, виведену на основі цих даних, та отримувати сповіщення у випадку зчитування показника поза нормою. В свою чергу розумний пристрій виконує зчитування показників здоров’я, їх обробку та аналіз, надсилає зібрані дані до бази даних, підраховує статистику на основі всіх отриманих показників здоров’я, перевіряє вимірювання на відповідність нормі, надсилає відповідне сповіщення у разі відхилення. 


3.2.2 Архітектура програмного забезпечення для IoT пристрою


Для імітації роботи розумного пристрою, в проєкті налаштовано автоматичне зчитування (імітація зчитування реальних показників) відповідного показника здоров’я раз на 5 хвилин.  Однією з частин проєкту є сервіс контролю значень MeasurementService.cs (див. Додаток Ж), який після зчитування виконує перевірку, чи входить отриманий показник до заданого діапазону нормальних значень. Якщо трапляється ситуація, де щойно отриманий показник, виходить за межі очікуємих значень, сервіс виводить відповідне повідомлення про це. 
Також  розроблене програмне забезпечення містить файли моделей, які застосовуються для роботи додатку, та файли з розширенням .json для забезпечення локалізації українською та англійською мовами. Запуск програмного забезпечення для IoT пристрою відбувається в головному файлі програми Program.cs (див. Додаток Е). MeasurementService.cs (див. Додаток Ж) – сервіс, який зчитує, оброблює та аналізує отриманні вимірювання.


3.2.3 Опис частин коду програмного забезпечення для IoT пристрою
3.2.3.1 Моделі даних та сервіси 


Першим кроком при створенні програмного забезпечення був опис моделі вимірювання, яка є основною в даному застосунку та буде використовуватись при отриманні, аналізу та відправки значень:
1 namespace StayHealthIoT.Models
2 {
3     public class Measurement
4     {
5         public int MeasurementId { get; set; }
6         public int PatientId { get; set; }
7         public float MeasurementValue { get; set; }
8         public int MedicalDeviceId { get; set; }
9         public DateTime MeasurementDate { get; set; } = DateTime.UtcNow;
10     }
11 
12 }
У рядку 9 можемо побачити отримання та приведення локальної дати та часу користувача до загальноприйнятого формату UTC. 
Наступним кроком було створення та реалізація логіки сервісу для контролю отриманих показників (див. Додаток Ж). Та створені два контролери – MeasurementsController та StatisticsController, для отримання всіх показників пацієнта та статистики відповідно.


3.2.3.2 Локалізація


У розробленому програмному забезпеченні для IoT пристрою наявна реалізація сервісу, для забезпечення локалізації (українська та англійська мови).
Для вибору мови використовується метод GetUserLocale():
1      static Locale GetUserLocale()
2      {
3          while (true)
4          {
5              Console.Write("Select your language (en/ua): ");
6              string selectedLocale = Console.ReadLine().ToLower();
7 
8              if (selectedLocale == "en" || selectedLocale == "ua")
9              {
10                  return selectedLocale == "en" ? Locale.en : Locale.ua;
11             }
12 
13              Console.WriteLine("Invalid choice. Please enter 'en' for English or 'ua' for Ukrainian.");
14          }
15      }
Після здійснення вибору, всі ресурси, необхідні для локалізації додатку, завантажуються з відповідного файлу .json. У випадку відсутності файлу з обраною мовою, завантажується файл української як стандартної мови. Подальші налаштування пристрою відбуваються з використанням обраної мови (рис. 3.2.7, рис. 3.2.8).

 
Рисунок 3.2.7 – Інтерфейс налаштування програмного забезпечення IoT пристрою для української мови

 
Рисунок 3.2.8 – Інтерфейс налаштування програмного забезпечення IoT пристрою для англійської мови

Зазначені налаштування повинні виконуватись тільки один раз при першому запуску пристрою, для підключення та встановлення зв’язку з профілем відповідного пацієнта. 


3.2.3.3 Статистика

 
Для отримання статистики використовується контролер StatisticsController.cs (див. Додаток Ж), який зчитує всі вимірювання з бази даних, обчислює середнє значення показників для заданого пацієнта, і повертає це середнє значення у відповідь на HTTP-запит.

 
ВИСНОВКИ


Під час виконання даної курсової роботи була розроблена програмна система «StayHealth» для дистанційного моніторингу стану здоров’я.
Програмна система складається з серверу та бази даних, веб-додатку, мобільного додатку та розумного годиннику. Серверна частина була створена за допомогою мови програмування С# на платформі .NET 8, з використанням ASP.NET Core 8.0, для бази даних було використано MS SQL Server 2019. Веб-додаток був створений за допомогою Angular 17, з використанням мови програмування TypeScript, також буде застосовано Bootstrap для забезпечення адаптивності веб-клієнта. Прототип розумного годиннику розроблено за допомогою пристрою Raspberry Pi, з застосуванням API, розробленого за допомогою ASP.NET Core 8.0.
Отримана у якості результату програмна система «StayHealth» зменшить навантаження на лікарні та покращить якість медичної допомоги. Лікарі зможуть створювати та швидко переглядати медичні картки своїх пацієнтів, а пацієнти зможуть легко вносити свої показники до картки та переглядати їх.


ПЕРЕЛІК ПОСИЛАНЬ


1. Прийоми об’єктно-орієнтованого проектування. Патерни проектування / Е. Гамма та ін. 368 с.
2. Мартін Р. Чистий код. Створення і рефакторинг за допомогою Agile : 2-ге вид. Харків : Фабула, 2019. 448 с.
3. Мартін Р. Чиста архітектура. Харків : Фабула, 2019. 368 с.
4. Відеозапис функціонального тестування Програмної системи дистанційного моніторингу стану здоров’я пацієнтів. URL: https://youtu.be/cnRjalCDbwM (дата звернення: 12.06.2024).
5. Програмний код розробленої системи. URL: https://github.com/NureVoskoboinikovaKateryna/apzkr-pzpi-21-3-voskoboinikova-kateryna (дата звернення: 10.06.2024).

 
ДОДАТОК А
Схеми та діаграми


Рисунок А.1 – Діаграма прецедентів для серверної частини


Рисунок А.2 – ER-діаграма для серверної частини

 
Рисунок А.3 – Діаграма прецедентів для клієнтської частини

 
Рисунок А.4 – Діаграма прецедентів для програмного забезпечення ІоТ-пристрою

 
Рисунок А.5 – Діаграма розгортання програмної системи

 
Рисунок А.6 – Діаграма компонентів програмної системи

 
ДОДАТОК Б
Специфікація REST


Таблиця Б.1 – контролер Administrator
Посилання	Метод	Призначення
/api/Administrators	GET	Отримання всіх адміністраторів
/api/Administrators/{adminId}	GET	Отримання конкретного адміністратора за ідентифікатором
/api/Administrators/email/{email}	GET	Отримання адміністратора за email
/api/Administrators	POST	Створення нового адміністратора
/api/Administrators/{adminId}	PUT	Оновлення інформації про адміністратора за ідентифікатором
/api/Administrators/{adminId}	DELETE	Видалення адміністратора за ідентифікатором
/api/Administrators/acc/{adminId}	DELETE	Видалення адміністратора та його облікового запису за ідентифікатором

Таблиця Б.2 – контролер BloodTypes
Посилання	Метод	Призначення
/api/BloodTypes	GET	Отримання всіх груп крові
/api/BloodTypes/{btypeId}	GET	Отримання групи крові за ідентифікатором
/api/BloodTypes/patients/{btypeId}	GET	Отримання пацієнтів з певною групою крові

Таблиця Б.3 – контролер Companies
Посилання	Метод	Призначення
/api/Companies	GET	Отримання всіх компаній
/api/Companies/{companyId}	GET	Отримання компанії за ідентифікатором
/api/Companies/patients/{companyId}	GET	Отримання пацієнтів, які належать певній компанії
/api/Companies	POST	Створення нової компанії
/api/Companies/{companyId}	PUT	Оновлення інформації про компанію за її ідентифікатором
/api/Companies/{companyId}	DELETE	Видалення компанії за її ідентифікатором

Таблиця Б.4 – контролер CompanyManagers
Посилання	Метод	Призначення
/api/CompanyManagers	GET	Отримання всіх менеджерів компаній
/api/CompanyManagers/{managerId}	GET	Отримання менеджера компанії за ідентифікатором
/api/CompanyManagers/email/{email}	GET	Отримання менеджера компанії за email
/api/CompanyManagers	POST	Створення нового менеджера компанії
/api/CompanyManagers/{managerId}	PUT	Оновлення інформації про менеджера компанії за ідентифікатором
/api/CompanyManagers/{managerId}	DELETE	Видалення менеджера компанії за ідентифікатором
/api/CompanyManagers/acc/{managerId}	DELETE	Видалення менеджера компанії та його облікового запису за ідентифікатором

Таблиця Б.5 – контролер Doctors
Посилання	Метод	Призначення
/api/Doctors	GET	Отримання всіх лікарів
/api/Doctors/{doctorId}	GET	Отримання лікаря за ідентифікатором
/api/Doctors/email/{email}	GET	Отримання лікаря за email
/api/Doctors/mrecords/{doctorId}	GET	Отримання медичних записів лікаря за ідентифікатором
/api/Doctors	POST	Створення нового лікаря
/api/Doctors/{doctorId}	PUT	Оновлення інформації про лікаря за ідентифікатором
/api/Doctors/{doctorId}	DELETE	Видалення лікаря за ідентифікатором
/api/Doctors/acc/{doctorId}	DELETE	Видалення лікаря та його облікового запису за ідентифікатором

Таблиця Б.6 – контролер Patients
Посилання	Метод	Призначення
/api/Patients	GET	Отримати всіх пацієнтів
/api/Patients/{patientId}	GET	Отримати пацієнта за ідентифікатором

Продовження таблиці Б.6
Посилання	Метод	Призначення
/api/Patients/email/{email}	GET	Отримати пацієнта за email
/api/Patients/doctor/{doctorId}	GET	Отримати пацієнтів за ідентифікатором лікаря
/api/Patients/notifications/{patientId}	GET	Отримати сповіщення пацієнта за ідентифікатором
/api/Patients/measurements/{patientId}	GET	Отримати вимірювання пацієнта за ідентифікатором
/api/Patients/mrecords/{patientId}	GET	Отримати медичні записи пацієнта за ідентифікатором
/api/Patients/email/{email}	GET	Отримати пацієнта за email
/api/Patients/doctor/{doctorId}	GET	Отримати пацієнтів за ідентифікатором лікаря

Таблиця Б.7 – контролер UserAccount
Посилання	Метод	Призначення
/api/Accounts/register-admin	POST	Зареєструвати адміністратора
/api/Accounts/register-manager	POST	Зареєструвати менеджера компанії

Продовження таблиці Б.7
Посилання	Метод	Призначення
/api/Accounts/register-doctor	POST	Зареєструвати лікаря
/api/Accounts/register-patient	POST	Зареєструвати пацієнта
/api/Accounts/login	POST	Увійти в систему

Таблиця Б.8 – контролер MedicalRecord
Посилання	Метод	Призначення
/api/MedicalRecords	GET	Отримати всі медичні записи
/api/MedicalRecords/{mrecordId}	GET	Отримати медичний запис за ідентифікатором
/api/MedicalRecords/patient/{patientId}	GET	Отримати медичні записи пацієнта за ідентифікатором
/api/MedicalRecords/patient/{patientId}/doctor/{doctorId}	GET	Отримати медичні записи пацієнта за ідентифікатором пацієнта та лікаря
/api/MedicalRecords/doctor/{doctorId}	GET	Отримати медичні записи лікаря за ідентифікатором
/api/MedicalRecords	POST	Створити новий медичний запис
/api/MedicalRecords/{mrecordId}	PUT	Оновити існуючий медичний запис


ДОДАТОК В
NotificationRepository.cs


01 using healthguard.Data;
02 using healthguard.Interfaces;
03 using healthguard.Models;
04 
05 namespace healthguard.Repository
06 {
07     public class NotificationRepository : INotificationRepository
08     {
09         private readonly DataContext _context;
10 
11         public NotificationRepository(DataContext context)
12         {
13             _context = context;
14         }
15 
16         public bool CreateNotification(Notification notification)
17         {
18             _context.Add(notification);
19             return Save();
20         }
21 
22         public bool DeleteNotification(Notification notification)
23         {
24             _context.Remove(notification);
25             return Save();
26         }
27 
28         public Notification GetNotification(int notifId)
29         {
30             return _context.Notifications.Where(e => e.NotificationId == notifId).FirstOrDefault();
31         }
32 
33         public ICollection<Notification> GetNotifications()
34         {
35             return _context.Notifications.OrderBy(e => e.NotificationId).ToList();
36         }
37 
38         public ICollection<Notification> GetNotificationsByDoctor(int doctorId)
39         {
40             return _context.Notifications.Where(e => e.SenderId == doctorId).ToList();
41         }
42 
43         public ICollection<Notification> GetNotificationsByPatient(int patientId)
44         {
45             return _context.Notifications.Where(e => e.PatientId == patientId).ToList();
46         }
47 
48         public bool NotificationExists(int notifId)
49         {
50             return _context.Notifications.Any(e => e.NotificationId == notifId);
51         }
52 
53         public bool Save()
54         {
55             var saved = _context.SaveChanges();
56             return saved > 0;
57         }
58 
59         public bool UpdateNotification(Notification notification)
60         {
61             _context.Update(notification);
62             return Save();
63         }
64     }
65 }

 
ДОДАТОК Г
app.module.ts


001 import { NgModule } from '@angular/core';
002 import { BrowserModule } from '@angular/platform-browser';
003 
004 import { AppRoutingModule } from './app-routing.module';
005 import { AppComponent } from './app.component';
006 import { HeaderComponent } from './reusable/header/header.component';
007 import { LoginComponent } from './ui/login/login.component';
008 import { RegisterComponent } from './ui/register/register.component';
009 import { HttpClientModule, HTTP_INTERCEPTORS, HttpClient } from '@angular/common/http';
010 import { FormsModule } from '@angular/forms';
011 import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
012 import { ToastrModule } from 'ngx-toastr';
013 import { AuthInterceptor } from './interceptors/auth-interceptor.interceptor';
014 import { HomeComponent } from './ui/home/home.component';
015 import { PatientRegisterFormComponent } from './ui/register/patient-register-form/patient-register-form.component';
016 import { DoctorRegisterFormComponent } from './ui/register/doctor-register-form/doctor-register-form.component';
017 import { ManagerRegisterFormComponent } from './ui/register/manager-register-form/manager-register-form.component';
018 import { NotificationsComponent } from './ui/notifications/notifications.component';
019 import { MedicalRecordsComponent } from './ui/medical-records/medical-records.component';
020 import { MeasurementsComponent } from './ui/measurements/measurements.component';
021 import { PatientProfileComponent } from './ui/patient-profile/patient-profile.component';
022 import { EditPatientProfileComponent } from './ui/patient-profile/edit-patient-profile/edit-patient-profile.component';
023 import { DoctorProfileComponent } from './ui/doctor-profile/doctor-profile.component';
024 import { ManagerProfileComponent } from './ui/manager-profile/manager-profile.component';
025 import { EditDoctorProfileComponent } from './ui/doctor-profile/edit-doctor-profile/edit-doctor-profile.component';
026 import { EditManagerProfileComponent } from './ui/manager-profile/edit-manager-profile/edit-manager-profile.component';
027 import { DmedicalRecordsComponent } from './ui/dmedical-records/dmedical-records.component';
028 import { AddDmedicalRecordComponent } from './ui/dmedical-records/add-dmedical-record/add-dmedical-record.component';
029 import { EditDmedicalRecordComponent } from './ui/dmedical-records/edit-dmedical-record/edit-dmedical-record.component';
030 import { DnotificationsComponent } from './ui/dnotifications/dnotifications.component';
031 import { EditDnotificationComponent } from './ui/dnotifications/edit-dnotification/edit-dnotification.component';
032 import { AddDnotificationComponent } from './ui/dnotifications/add-dnotification/add-dnotification.component';
033 import { DpatientsComponent } from './ui/dpatients/dpatients.component';
034 import { MpatientsComponent } from './ui/mpatients/mpatients.component';
035 import { AdminPanelComponent } from './ui/admin-panel/admin-panel.component';
036 import { PatientsComponent } from './ui/admin-panel/patients/patients.component';
037 import { AdministratorsComponent } from './ui/admin-panel/administrators/administrators.component';
038 import { DoctorsComponent } from './ui/admin-panel/doctors/doctors.component';
039 import { CompanyManagersComponent } from './ui/admin-panel/company-managers/company-managers.component';
040 import { CompaniesComponent } from './ui/admin-panel/companies/companies.component';
041 import { MedicalDevicesComponent } from './ui/admin-panel/medical-devices/medical-devices.component';
042 import { MedicalDeviceTypesComponent } from './ui/admin-panel/medical-device-types/medical-device-types.component';
043 import { BloodTypesComponent } from './ui/admin-panel/blood-types/blood-types.component';
044 import { SpecializationsComponent } from './ui/admin-panel/specializations/specializations.component';
045 import { ManufacturersComponent } from './ui/admin-panel/manufacturers/manufacturers.component';
046 import { AdminMedicalRecordsComponent } from './ui/admin-panel/medical-records/medical-records.component';
047 import { AdminMeasurementsComponent } from './ui/admin-panel/measurements/measurements.component';
048 import { AdminNotificationsComponent } from './ui/admin-panel/notifications/notifications.component';
049 import { CreatePatientComponent } from './ui/admin-panel/patients/create-patient/create-patient.component';
050 import { PutPatientComponent } from './ui/admin-panel/patients/put-patient/put-patient.component';
051 import { CreateNotificationComponent } from './ui/admin-panel/notifications/create-notification/create-notification.component';
052 import { PutNotificationComponent } from './ui/admin-panel/notifications/put-notification/put-notification.component';
053 import { CreateManufacturerComponent } from './ui/admin-panel/manufacturers/create-manufacturer/create-manufacturer.component';
054 import { PutManufacturerComponent } from './ui/admin-panel/manufacturers/put-manufacturer/put-manufacturer.component';
055 import { CreateSpecializationComponent } from './ui/admin-panel/specializations/create-specialization/create-specialization.component';
056 import { PutSpecializationComponent } from './ui/admin-panel/specializations/put-specialization/put-specialization.component';
057 import { CreateCompanyComponent } from './ui/admin-panel/companies/create-company/create-company.component';
058 import { PutCompanyComponent } from './ui/admin-panel/companies/put-company/put-company.component';
059 import { CreateDoctorComponent } from './ui/admin-panel/doctors/create-doctor/create-doctor.component';
060 import { PutDoctorComponent } from './ui/admin-panel/doctors/put-doctor/put-doctor.component';
061 import { CreateAdministratorComponent } from './ui/admin-panel/administrators/create-administrator/create-administrator.component';
062 import { PutAdministratorComponent } from './ui/admin-panel/administrators/put-administrator/put-administrator.component';
063 import { CreateMedicalRecordComponent } from './ui/admin-panel/medical-records/create-medical-record/create-medical-record.component';
064 import { PutMedicalRecordComponent } from './ui/admin-panel/medical-records/put-medical-record/put-medical-record.component';
065 import { CreateMedicalDeviceTypeComponent } from './ui/admin-panel/medical-device-types/create-medical-device-type/create-medical-device-type.component';
066 import { PutMedicalDeviceTypeComponent } from './ui/admin-panel/medical-device-types/put-medical-device-type/put-medical-device-type.component';
067 import { CreateMedicalDeviceComponent } from './ui/admin-panel/medical-devices/create-medical-device/create-medical-device.component';
068 import { PutMedicalDeviceComponent } from './ui/admin-panel/medical-devices/put-medical-device/put-medical-device.component';
069 import { CreateCompanyManagerComponent } from './ui/admin-panel/company-managers/create-company-manager/create-company-manager.component';
070 import { PutCompanyManagerComponent } from './ui/admin-panel/company-managers/put-company-manager/put-company-manager.component';
071 import { CreateMeasurementComponent } from './ui/admin-panel/measurements/create-measurement/create-measurement.component';
072 import { TranslateModule, TranslateLoader } from '@ngx-translate/core';
073 import { TranslateHttpLoader } from '@ngx-translate/http-loader';
074 
075 export function HttpLoaderFactory(http: HttpClient) {
076   return new TranslateHttpLoader(http);
077 }
078 
079 @NgModule({
080   declarations: [
081     AppComponent,
082     HeaderComponent,
083     LoginComponent,
084     RegisterComponent,
085     HomeComponent,
086     PatientRegisterFormComponent,
087     DoctorRegisterFormComponent,
088     ManagerRegisterFormComponent,
089     NotificationsComponent,
090     MedicalRecordsComponent,
091     MeasurementsComponent,
092     PatientProfileComponent,
093     EditPatientProfileComponent,
094     DoctorProfileComponent,
095     ManagerProfileComponent,
096     EditDoctorProfileComponent,
097     EditManagerProfileComponent,
098     DmedicalRecordsComponent,
099     AddDmedicalRecordComponent,
100     EditDmedicalRecordComponent,
101     DnotificationsComponent,
102     EditDnotificationComponent,
103     AddDnotificationComponent,
104     DpatientsComponent,
105     MpatientsComponent,
106     AdminPanelComponent,
107     PatientsComponent,
108     AdministratorsComponent,
109     DoctorsComponent,
110     CompanyManagersComponent,
111     CompaniesComponent,
112     MedicalDevicesComponent,
113     MedicalDeviceTypesComponent,
114     BloodTypesComponent,
115     SpecializationsComponent,
116     ManufacturersComponent,
117     AdminMedicalRecordsComponent,
118     AdminMeasurementsComponent,
119     AdminNotificationsComponent,
120     CreatePatientComponent,
121     PutPatientComponent,
122     CreateNotificationComponent,
123     PutNotificationComponent,
124     CreateMedicalRecordComponent,
125     PutMedicalRecordComponent,
126     CreateManufacturerComponent,
127     PutManufacturerComponent,
128     CreateSpecializationComponent,
129     PutSpecializationComponent,
130     CreateMedicalDeviceTypeComponent,
131     PutMedicalDeviceTypeComponent,
132     CreateMedicalDeviceComponent,
133     PutMedicalDeviceComponent,
134     CreateCompanyComponent,
135     PutCompanyComponent,
136     CreateCompanyManagerComponent,
137     PutCompanyManagerComponent,
138     CreateDoctorComponent,
139     PutDoctorComponent,
140     CreateAdministratorComponent,
141     PutAdministratorComponent,
142     CreateMeasurementComponent
143   ],
144   imports: [
145     BrowserModule,
146     AppRoutingModule,
147     HttpClientModule,
148     FormsModule,
149     BrowserAnimationsModule,
150     ToastrModule.forRoot({
151       maxOpened: 3
152     }),
153     TranslateModule.forRoot({
154       loader: {
155         provide: TranslateLoader,
156         useFactory: HttpLoaderFactory,
157         deps: [HttpClient]
158       }
159     })
160   ],
161   providers: [{
162     provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true
163   }],
164   bootstrap: [AppComponent]
165 })
166 export class AppModule { }

 
ДОДАТОК Д
app-routing.module.ts


001 import { NgModule } from '@angular/core';
002 import { RouterModule, Routes } from '@angular/router';
003 
004 import { LoginComponent } from './ui/login/login.component';
005 import { RegisterComponent } from './ui/register/register.component';
006 import { HomeComponent } from './ui/home/home.component';
007 import { NotificationsComponent } from './ui/notifications/notifications.component';
008 import { MedicalRecordsComponent } from './ui/medical-records/medical-records.component';
009 import { MeasurementsComponent } from './ui/measurements/measurements.component';
010 import { authorizedGuard } from './guards/authorized.guard';
011 import { PatientProfileComponent } from './ui/patient-profile/patient-profile.component';
012 import { allowedToGuard } from './guards/allowed-to.guard';
013 import { DoctorProfileComponent } from './ui/doctor-profile/doctor-profile.component';
014 import { ManagerProfileComponent } from './ui/manager-profile/manager-profile.component';
015 import { DmedicalRecordsComponent } from './ui/dmedical-records/dmedical-records.component';
016 import { AddDmedicalRecordComponent } from './ui/dmedical-records/add-dmedical-record/add-dmedical-record.component';
017 import { EditDmedicalRecordComponent } from './ui/dmedical-records/edit-dmedical-record/edit-dmedical-record.component';
018 import { DnotificationsComponent } from './ui/dnotifications/dnotifications.component';
019 import { EditDnotificationComponent } from './ui/dnotifications/edit-dnotification/edit-dnotification.component';
020 import { AddDnotificationComponent } from './ui/dnotifications/add-dnotification/add-dnotification.component';
021 import { DpatientsComponent } from './ui/dpatients/dpatients.component';
022 import { MpatientsComponent } from './ui/mpatients/mpatients.component';
023 import { AdminPanelComponent } from './ui/admin-panel/admin-panel.component';
024 import { isAdminGuard } from './guards/is-admin.guard';
025 import { CreatePatientComponent } from './ui/admin-panel/patients/create-patient/create-patient.component';
026 import { PutPatientComponent } from './ui/admin-panel/patients/put-patient/put-patient.component';
027 import { CreateSpecializationComponent } from './ui/admin-panel/specializations/create-specialization/create-specialization.component';
028 import { PutSpecializationComponent } from './ui/admin-panel/specializations/put-specialization/put-specialization.component';
029 import { CreateNotificationComponent } from './ui/admin-panel/notifications/create-notification/create-notification.component';
030 import { PutNotificationComponent } from './ui/admin-panel/notifications/put-notification/put-notification.component';
031 import { CreateMedicalRecordComponent } from './ui/admin-panel/medical-records/create-medical-record/create-medical-record.component';
032 import { PutMedicalRecordComponent } from './ui/admin-panel/medical-records/put-medical-record/put-medical-record.component';
033 import { CreateMedicalDeviceTypeComponent } from './ui/admin-panel/medical-device-types/create-medical-device-type/create-medical-device-type.component';
034 import { PutMedicalDeviceTypeComponent } from './ui/admin-panel/medical-device-types/put-medical-device-type/put-medical-device-type.component';
035 import { CreateMedicalDeviceComponent } from './ui/admin-panel/medical-devices/create-medical-device/create-medical-device.component';
036 import { PutMedicalDeviceComponent } from './ui/admin-panel/medical-devices/put-medical-device/put-medical-device.component';
037 import { CreateManufacturerComponent } from './ui/admin-panel/manufacturers/create-manufacturer/create-manufacturer.component';
038 import { PutManufacturerComponent } from './ui/admin-panel/manufacturers/put-manufacturer/put-manufacturer.component';
039 import { CreateDoctorComponent } from './ui/admin-panel/doctors/create-doctor/create-doctor.component';
040 import { PutDoctorComponent } from './ui/admin-panel/doctors/put-doctor/put-doctor.component';
041 import { CreateCompanyComponent } from './ui/admin-panel/companies/create-company/create-company.component';
042 import { CreateCompanyManagerComponent } from './ui/admin-panel/company-managers/create-company-manager/create-company-manager.component';
043 import { PutCompanyManagerComponent } from './ui/admin-panel/company-managers/put-company-manager/put-company-manager.component';
044 import { PutCompanyComponent } from './ui/admin-panel/companies/put-company/put-company.component';
045 import { CreateAdministratorComponent } from './ui/admin-panel/administrators/create-administrator/create-administrator.component';
046 import { PutAdministratorComponent } from './ui/admin-panel/administrators/put-administrator/put-administrator.component';
047 import { CreateMeasurementComponent } from './ui/admin-panel/measurements/create-measurement/create-measurement.component';
048 
049 const routes: Routes = [
050   { path: "home", component: HomeComponent, canActivate: [allowedToGuard] },
051   { path: "", redirectTo: "/home", pathMatch: "full" },
052   { path: "login", component: LoginComponent, canActivate: [allowedToGuard] },
053   { path: "register", component: RegisterComponent, canActivate: [allowedToGuard] },
054 
055   { path: "notifications", component: NotificationsComponent, canActivate: [authorizedGuard] },
056   { path: "medical-records", component: MedicalRecordsComponent, canActivate: [authorizedGuard] },
057   { path: "dmedical-records", component: DmedicalRecordsComponent, canActivate: [authorizedGuard] },
058   { path: "measurements", component: MeasurementsComponent, canActivate: [authorizedGuard] },
059   { path: "pprofile/:patientId", component: PatientProfileComponent, canActivate: [authorizedGuard] },
060   { path: "dprofile/:doctorId", component: DoctorProfileComponent, canActivate: [authorizedGuard] },
061   { path: "mprofile/:managerId", component: ManagerProfileComponent, canActivate: [authorizedGuard] },
062   { path: "add-mrecord", component: AddDmedicalRecordComponent, canActivate: [authorizedGuard] },
063   { path: "edit-record/:medicalRecordId", component: EditDmedicalRecordComponent, canActivate: [authorizedGuard] },
064   { path: "dnotifications", component: DnotificationsComponent, canActivate: [authorizedGuard] },
065   { path: "edit-dnotification/:notificationId", component: EditDnotificationComponent, canActivate: [authorizedGuard] },
066   { path: "add-dnotification", component: AddDnotificationComponent, canActivate: [authorizedGuard] },
067   { path: "dpatients", component: DpatientsComponent, canActivate: [authorizedGuard] },
068   { path: "mpatients", component: MpatientsComponent, canActivate: [authorizedGuard] },
069 
070   { path: "admin-panel", component: AdminPanelComponent, canActivate: [isAdminGuard] },
071   { path: "create-patient", component: CreatePatientComponent, canActivate: [isAdminGuard] },
072   { path: "put-patient/:patientId", component: PutPatientComponent, canActivate: [isAdminGuard] },
073   { path: "create-specialization", component: CreateSpecializationComponent, canActivate: [isAdminGuard] },
074   { path: "put-specialization/:spezId", component: PutSpecializationComponent, canActivate: [isAdminGuard] },
075   { path: "create-notification", component: CreateNotificationComponent, canActivate: [isAdminGuard] },
076   { path: "put-notification/:notificationId", component: PutNotificationComponent, canActivate: [isAdminGuard] },
077   { path: "create-medical-record", component: CreateMedicalRecordComponent, canActivate: [isAdminGuard] },
078   { path: "put-medical-record/:medicalRecordId", component: PutMedicalRecordComponent, canActivate: [isAdminGuard] },
079   { path: "create-medical-device-type", component: CreateMedicalDeviceTypeComponent, canActivate: [isAdminGuard] },
080   { path: "put-medical-device-type/:mDeviceTypeId", component: PutMedicalDeviceTypeComponent, canActivate: [isAdminGuard] },
081   { path: "create-medical-device", component: CreateMedicalDeviceComponent, canActivate: [isAdminGuard] },
082   { path: "put-medical-device/:mDeviceId", component: PutMedicalDeviceComponent, canActivate: [isAdminGuard] },
083   { path: "create-manufacturer", component: CreateManufacturerComponent, canActivate: [isAdminGuard] },
084   { path: "put-manufacturer/:manfId", component: PutManufacturerComponent, canActivate: [isAdminGuard] },
085   { path: "create-doctor", component: CreateDoctorComponent, canActivate: [isAdminGuard] },
086   { path: "put-doctor/:doctorId", component: PutDoctorComponent, canActivate: [isAdminGuard] },
087   { path: "create-company-manager", component: CreateCompanyManagerComponent, canActivate: [isAdminGuard] },
088   { path: "put-company-manager/:managerId", component: PutCompanyManagerComponent, canActivate: [isAdminGuard] },
089   { path: "create-company", component: CreateCompanyComponent, canActivate: [isAdminGuard] },
090   { path: "put-company/:companyId", component: PutCompanyComponent, canActivate: [isAdminGuard] },
091   { path: "create-administrator", component: CreateAdministratorComponent, canActivate: [isAdminGuard] },
092   { path: "put-administrator/:administratorId", component: PutAdministratorComponent, canActivate: [isAdminGuard] },
093   { path: "create-measurement", component: CreateMeasurementComponent, canActivate: [isAdminGuard] }
094 ];
095 
096 @NgModule({
097   imports: [RouterModule.forRoot(routes)],
098   exports: [RouterModule]
099 })
100 export class AppRoutingModule { }


ДОДАТОК Е
Program.cs програмного забезпечення для ІоТ-пристрою


001 using Microsoft.EntityFrameworkCore;
002 using Microsoft.Extensions.DependencyInjection;
003 using Microsoft.Extensions.Hosting;
004 using StayHealthIoT.Data;
005 using StayHealthIoT.Services;
006 using System;
007 using System.Collections.Generic;
008 using System.Globalization;
009 using System.IO;
010 using System.Text.Json;
011 
012 namespace StayHealthIoT
013 {
014 public class Program
015 {
016 public static int PatientId { get; private set; }
017 public static string MedicalDeviceId { get; private set; }
018 public static Dictionary<string, string> LocalizationResources { get; private set; }
019 
020 public static void Main(string[] args)
021 {
022 var builder = WebApplication.CreateBuilder(args);
023 
024 builder.Services.AddControllers();
025 builder.Services.AddDbContext<SmartWatchDbContext>(options =>
026 options.UseSqlServer(builder.Configuration.GetConnectionString("SmartWatchDbConnection")));
027 builder.Services.AddHostedService<MeasurementService>();
028 
029 builder.Services.AddSwaggerGen(c =>
030 {
031 c.SwaggerDoc("v1", new Microsoft.OpenApi.Models.OpenApiInfo { Title = "SmartWatch API", Version = "v1" });
032 });
033 
034 var app = builder.Build();
035 
036 app.UseSwagger();
037 app.UseSwaggerUI(c =>
038 {
039 c.SwaggerEndpoint("/swagger/v1/swagger.json", "SmartWatch API v1");
040 });
041 
042 app.UseRouting();
043 
044 app.UseAuthorization();
045 
046 app.MapControllers();
047 
048 var locale = GetUserLocale();
049 LocalizationResources = LoadLocalizationResource(locale);
050 
051 Console.WriteLine(LocalizationResources["EnterPatientId"]);
052 PatientId = int.Parse(Console.ReadLine());
053 
054 Console.WriteLine(LocalizationResources["EnterMedicalDeviceId"]);
055 MedicalDeviceId = Console.ReadLine();
056 
057 app.Run();
058 }
059 
060 static Locale GetUserLocale()
061 {
062 while (true)
063 {
064 Console.Write("Select your language (en/ua): ");
065 string selectedLocale = Console.ReadLine().ToLower();
066 
067 if (selectedLocale == "en" || selectedLocale == "ua")
068 {
69 return selectedLocale == "en" ? Locale.en : Locale.ua;
070 }
071 
072 Console.WriteLine("Invalid choice. Please enter 'en' for English or 'ua' for Ukrainian.");
073 }
074 }
075 
076 static Dictionary<string, string> LoadLocalizationResource(Locale locale)
077 {
078 string localizationFileName = $"Locales\\{locale}.json";
079 Dictionary<string, string> resource = new Dictionary<string, string>();
080 
081 try
082 {
083 string json = File.ReadAllText(localizationFileName);
084 resource = JsonSerializer.Deserialize<Dictionary<string, string>>(json);
085 }
086 catch (FileNotFoundException)
087 {
088 Console.WriteLine($"Localization file '{localizationFileName}' not found. Using default locale.");
089 string defaultLocalizationFileName = "Locales\\ua.json";
090 string json = File.ReadAllText(defaultLocalizationFileName);
091 resource = JsonSerializer.Deserialize<Dictionary<string, string>>(json);
092 }
093 catch (Exception ex)
094 {
095 Console.WriteLine($"Error loading localization: {ex.Message}");
096 }
097 
098 return resource;
099 }
100 }
101 
102 public enum Locale
103 {
104 en,
105 ua
106 }
107 }

 
ДОДАТОК Ж
MeasurementsController.cs програмного забезпечення для ІоТ-пристрою


01 using Microsoft.Extensions.DependencyInjection;
02 using Microsoft.Extensions.Hosting;
03 using StayHealthIoT.Data;
04 using StayHealthIoT.Models;
05 using System;
06 using System.Threading;
07 using System.Threading.Tasks;
08 
09 namespace StayHealthIoT.Services
10 {
11 public class MeasurementService : IHostedService, IDisposable
12 {
13 private Timer _timer;
14 private readonly IServiceScopeFactory _scopeFactory;
15 private readonly Random _random = new Random();
16 private const double MinTemp = 36.0;
17 private const double MaxTemp = 37.5;
18 
19 public MeasurementService(IServiceScopeFactory scopeFactory)
20 {
21 _scopeFactory = scopeFactory;
22 }
23 
24 public Task StartAsync(CancellationToken cancellationToken)
25 {
26 _timer = new Timer(DoWork, null, TimeSpan.Zero, TimeSpan.FromMinutes(5));
27 return Task.CompletedTask;
28 }
29 
30 private void DoWork(object state)
31 {
32 using var scope = _scopeFactory.CreateScope();
33 var context = scope.ServiceProvider.GetRequiredService<SmartWatchDbContext>();
34 
35 var temperature = _random.NextDouble() * (MaxTemp - MinTemp) + MinTemp;
36 
37 var measurement = new Measurement
38 {
39 PatientId = Program.PatientId,
40 MeasurementValue = (float)temperature,
41 MedicalDeviceId = Program.MedicalDeviceId,
42 MeasurementDate = DateTime.UtcNow
43 };
44 
45 context.Measurements.Add(measurement);
46 context.SaveChanges();
47 
48 if (temperature < MinTemp || temperature > MaxTemp)
49 {
50 Console.WriteLine(Program.LocalizationResources["TemperatureOutOfRange"], temperature);
51 }
52 }
53 
54 public Task StopAsync(CancellationToken cancellationToken)
55 {
56 _timer?.Change(Timeout.Infinite, 0);
57 return Task.CompletedTask;
58 }
59 
60 public void Dispose()
61 {
62 _timer?.Dispose();
63 }
64 }
65 }


ДОДАТОК И
Результат перевірки на плагіат

